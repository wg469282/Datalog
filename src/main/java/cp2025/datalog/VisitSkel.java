// File generated by the BNF Converter (bnfc 2.9.6.1).

package cp2025.datalog;

/*** Visitor Design Pattern Skeleton. ***/

/* This implements the common visitor design pattern.
   Tests show it to be slightly less efficient than the
   instanceof method, but easier to use.
   Replace the R and A parameters with the desired return
   and context types.*/

public class VisitSkel
{
  public class ProgramDefVisitor<R,A> implements cp2025.datalog.Absyn.ProgramDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.Program p, A arg)
    { /* Code for Program goes here */
      p.constantsdef_.accept(new ConstantsDefVisitor<R,A>(), arg);
      p.rulesdef_.accept(new RulesDefVisitor<R,A>(), arg);
      p.queriesdef_.accept(new QueriesDefVisitor<R,A>(), arg);
      return null;
    }
  }
  public class ConstantsDefVisitor<R,A> implements cp2025.datalog.Absyn.ConstantsDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.Constants p, A arg)
    { /* Code for Constants goes here */
      //for (String x: p.listlident_) {
        //x;
      //}
      return null;
    }
  }
  public class RulesDefVisitor<R,A> implements cp2025.datalog.Absyn.RulesDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.Rules p, A arg)
    { /* Code for Rules goes here */
      for (cp2025.datalog.Absyn.RuleDef x: p.listruledef_) {
        x.accept(new RuleDefVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class RuleDefVisitor<R,A> implements cp2025.datalog.Absyn.RuleDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.Rule p, A arg)
    { /* Code for Rule goes here */
      p.atomdef_.accept(new AtomDefVisitor<R,A>(), arg);
      for (cp2025.datalog.Absyn.AtomDef x: p.listatomdef_) {
        x.accept(new AtomDefVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class AtomDefVisitor<R,A> implements cp2025.datalog.Absyn.AtomDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.Atom p, A arg)
    { /* Code for Atom goes here */
      p.predicatedef_.accept(new PredicateDefVisitor<R,A>(), arg);
      for (cp2025.datalog.Absyn.Element x: p.listelement_) {
        x.accept(new ElementVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class ElementVisitor<R,A> implements cp2025.datalog.Absyn.Element.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.ConstElement p, A arg)
    { /* Code for ConstElement goes here */
      //p.lident_;
      return null;
    }
    public R visit(cp2025.datalog.Absyn.VarElement p, A arg)
    { /* Code for VarElement goes here */
      //p.uident_;
      return null;
    }
  }
  public class PredicateDefVisitor<R,A> implements cp2025.datalog.Absyn.PredicateDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.LPredicate p, A arg)
    { /* Code for LPredicate goes here */
      //p.lident_;
      return null;
    }
    public R visit(cp2025.datalog.Absyn.LSPredicate p, A arg)
    { /* Code for LSPredicate goes here */
      //p.lsident_;
      return null;
    }
  }
  public class QueriesDefVisitor<R,A> implements cp2025.datalog.Absyn.QueriesDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.Queries p, A arg)
    { /* Code for Queries goes here */
      for (cp2025.datalog.Absyn.StatementDef x: p.liststatementdef_) {
        x.accept(new StatementDefVisitor<R,A>(), arg);
      }
      return null;
    }
  }
  public class StatementDefVisitor<R,A> implements cp2025.datalog.Absyn.StatementDef.Visitor<R,A>
  {
    public R visit(cp2025.datalog.Absyn.Statement p, A arg)
    { /* Code for Statement goes here */
      p.predicatedef_.accept(new PredicateDefVisitor<R,A>(), arg);
      //for (String x: p.listlident_) {
        //x;
      //}
      return null;
    }
  }
}
